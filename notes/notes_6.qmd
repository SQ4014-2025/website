# Week 06 — Generating a software backend

This week focuses on *Generating a software backend*.

We are continuing the HAM radio practice-test app. In Week 05 we got a working scaffold (database + basic page). In **Week 06** the focus shifts from "it runs" to "it behaves like a real application": it must keep track of a test-taker over multiple clicks, handle restarts, and recover cleanly from bugs.


-   [What this week covers (in plain language)](#what-this-week-covers-in-plain-language)
-   [Recap of the app architecture so far](#recap-of-the-app-architecture-so-far)
-   [Why backend work matters here](#why-backend-work-matters-here)
-   [Symptom-driven debugging](#symptom-driven-debugging)
-   [Why this is a good learning bug](#why-this-is-a-good-learning-bug)
-   [What Tabnine is good at](#what-tabnine-is-good-at)
-   [What Tabnine is bad at (unless you guide it)](#what-tabnine-is-bad-at-unless-you-guide-it)
-   [A minimal but clean Flask app structure](#a-minimal-but-clean-flask-app-structure)
-   [Code example: enabling sessions and setting a secret key](#code-example-enabling-sessions-and-setting-a-secret-key)
-   [Code example: selecting questions once per session](#code-example-selecting-questions-once-per-session)
-   [Code example: route that shows the current question](#code-example-route-that-shows-the-current-question)
-   [Code example: recording an answer (POST)](#code-example-recording-an-answer-post)
-   [Make failures reproducible](#make-failures-reproducible)
-   [Code example: quick smoke test with requests](#code-example-quick-smoke-test-with-requests)
-   [Common error classes in this week](#common-error-classes-in-this-week)
-   [Summing Up](#summing-up)
-   [Checks for understanding](#checks-for-understanding)

## What this week covers (in plain language) {#what-this-week-covers-in-plain-language}

-   Turning a static “dump of questions” into an interactive workflow.
-   Creating and maintaining **persistent sessions** so each student sees a consistent test flow.
-   Implementing backend features in **Flask** with **database integration**.
-   Using **Tabnine** to:
    -   generate code (scaffolds and functions)
    -   debug and fix errors
    -   refactor toward cleaner modules
-   Crafting prompts that produce *useful* help instead of vague output.

# Key terms

-   **Tabnine** — AI coding assistant integrated into IDEs (VS Code etc.) that can autocomplete, chat, and help refactor.
-   **session** — A way to remember who the user is between requests; this week focuses on keeping “test-taker state”.
-   **Flask** — A lightweight Python web framework; here it serves pages and handles requests for the practice test app.
-   **SQLite** — A file-based relational database used to store questions; errors often surface when files/paths/locks are wrong.
-   **user state** — The data you must track during a test: which question number, chosen answers, score, and timing.

# Where we are in the project

## Recap of the app architecture so far {#recap-of-the-app-architecture-so-far}

By now you have:

-   A **SQLite** database file (for example `data/questions.db`).
-   Model code that opens a connection and fetches question data.
-   A **Flask** app entry point that defines routes and renders templates.

The problem: the app *works once*, then fails on reload / restart / second session.

That is a classic “state + lifecycle” bug.

## Why backend work matters here {#why-backend-work-matters-here}

A lot of beginner web apps fail because they confuse:

-   **a request** (one browser hit)
-   **a session** (a user across many requests)
-   **an application run** (the server process)

When you build a “test” experience, you are building a mini state machine:

-   Start test → choose 35 questions → show question 1 → record answer → show question 2 → … → show results.

If you don’t store state, every click resets you.

# Sessions: the core idea

A browser talks to your server with HTTP. HTTP is *stateless*.

So you must choose where to store “memory”:

-   client-side (cookies / local storage)
-   server-side (in-memory, file, database, cache)
-   hybrid (cookie contains a session key; server stores the session data)

In Flask, the default **session** object is cookie-based (signed) — good for small, non-sensitive state.

### What you should store in a test session

Typical items:

-   `session_id` (or a server-side key)
-   `question_ids` selected for this test
-   `current_index` (which question the student is on)
-   `answers` (dictionary mapping question_id → chosen option)
-   `start_time` (optional)
-   `score` (optional, may be computed at end)

### What you should *not* store

-   the entire question database
-   secrets (API keys)
-   large blobs of data

# Debugging the “works once” problem

## Symptom-driven debugging {#symptom-driven-debugging}

When an app works once and fails on the second run, the cause is often one of:

-   state is not reset correctly
-   file handles are not closed
-   database locks persist
-   cached objects survive between sessions
-   assumptions about directory paths are wrong

This week shows a concrete example: a **SQLite error** that appears when loading again.

## Why this is a good learning bug {#why-this-is-a-good-learning-bug}

It forces you to think in layers:

1.  What is the *user action* (reload, restart, new browser)?
2.  What is the *server lifecycle* (process reused, dev server reload)?
3.  What is the *data layer lifecycle* (connection, cursor, transaction)?

# Working with Tabnine as a coding partner

## What Tabnine is good at {#what-tabnine-is-good-at}

-   producing “starter” implementations quickly
-   suggesting fixes when you show a stack trace
-   refactoring repetitive code into functions/classes
-   generating tests and edge cases (if you ask clearly)

## What Tabnine is bad at (unless you guide it) {#what-tabnine-is-bad-at-unless-you-guide-it}

-   understanding your full codebase without context
-   making architectural decisions *for you*
-   reliably preserving your project conventions

### Practical prompting pattern

When you ask for help, include:

-   the goal in one sentence
-   the current behavior
-   the error message / stack trace
-   the relevant file(s) and function(s)
-   what you already tried

Example prompt structure (adapt for Tabnine or any assistant):

> I have a Flask app that selects 35 questions from SQLite. It works on first load but fails on reload with this error: ... Here is my DatabaseConnection context manager and the route handler. Please diagnose the root cause and suggest a minimal fix.

# Implementing the backend features (Flask + DB)

## A minimal but clean Flask app structure {#a-minimal-but-clean-flask-app-structure}

A simple, testable structure often looks like:

-   `app/__init__.py` (create_app)
-   `app/routes.py` (blueprints)
-   `app/models/` (db + query logic)
-   `app/templates/` (Jinja2 HTML)
-   `tests/` (pytest)

This week keeps things lightweight but pushes toward separation:

-   routes should be thin
-   database code should be isolated
-   “session state” should be explicit

## Code example: enabling sessions and setting a secret key {#code-example-enabling-sessions-and-setting-a-secret-key}

```python
from flask import Flask

def create_app():
    app = Flask(__name__)
    # In production: load from environment variable
    app.config["SECRET_KEY"] = "dev-only-change-me"
    return app
```

### Why `SECRET_KEY` matters

Flask signs session cookies. If the key changes between runs, the server can’t validate old cookies. That can look like “random” session failures.

## Code example: selecting questions once per session {#code-example-selecting-questions-once-per-session}

```python
import random
from flask import session

def init_test_session(question_ids, n=35):
    # Store a stable random selection for this user
    chosen = random.sample(question_ids, n)
    session["question_ids"] = chosen
    session["current_index"] = 0
    session["answers"] = {}
```

### Pitfall

If you re-sample on every request, the test becomes inconsistent.

## Code example: route that shows the current question {#code-example-route-that-shows-the-current-question}

```python
from flask import render_template, session, redirect, url_for

@app.route("/question")
def show_question():
    ids = session.get("question_ids")
    if not ids:
        return redirect(url_for("start_test"))

    idx = session.get("current_index", 0)
    qid = ids[idx]
    question = Questions(cursor).fetch_by_id(qid)

    return render_template("question.html", question=question, index=idx+1, total=len(ids))
```

## Code example: recording an answer (POST) {#code-example-recording-an-answer-post}

```python
from flask import request

@app.post("/answer")
def record_answer():
    qid = request.form["question_id"]
    choice = request.form["choice"]

    answers = session.get("answers", {})
    answers[qid] = choice
    session["answers"] = answers

    session["current_index"] = session.get("current_index", 0) + 1
    return redirect(url_for("show_question"))
```

### Why we reassign `session["answers"]`

With cookie-based sessions, Flask detects modifications when you set a key. Mutating a nested dict *may not* be detected consistently unless you reassign.

# Testing and troubleshooting

## Make failures reproducible {#make-failures-reproducible}

Good debugging is about making “sometimes” become “always”.

Try:

-   restart server, load app, answer 1 question, reload
-   open private window (new session), repeat
-   delete cookies, repeat

## Code example: quick smoke test with requests {#code-example-quick-smoke-test-with-requests}

```python
import requests

base = "http://127.0.0.1:5000"
with requests.Session() as s:
    r = s.get(f"{base}/start")
    r.raise_for_status()
    r = s.get(f"{base}/question")
    print(r.status_code, len(r.text))
```

## Common error classes in this week {#common-error-classes-in-this-week}

-   SQLite “database is locked”
-   file path errors (relative vs absolute)
-   session cookie invalidation
-   KeyError from missing session keys


## Summing Up {#summing-up}

-   Chapter 6 is about turning a basic Flask + SQLite app into an interactive experience.
-   The technical core is **sessions**: how to persist a user’s progress across requests.
-   The practical workflow skill is using **Tabnine** effectively: provide context, ask for minimal diffs, and validate with tests.

## Checks for understanding {#checks-for-understanding}

-   Explain the difference between a request, a session, and a server process.
-   List 5 pieces of state you need for a practice test workflow.
-   Describe one reason a SQLite app works once but fails on reload.
-   Give an example of a *good* debugging prompt for Tabnine.

