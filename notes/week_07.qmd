# Week 07 — Building user interfaces with ChatGPT

> **Micro-quotes:**
> "Even seasoned developers can find UI design tough, and  generative AI tools help tremendously."
> "AI tools provide a big boost for developers who aren’t great at UI."
> "First, we need to build a great prompt for this."
> "7.1	 Getting our strategy from our AI tools Before we approach these tools, we should think carefully about our prompt."
> "If we say  “generate a frontend for my application” without enough information, the guidance  will be too vague."
> "There is a time and a place for brief prompts."

## What this week is doing (big picture)
This week switches focus from **backend logic** to the part users actually *touch*: the **user interface (UI)**. The aim is to use chat-based generative AI (especially ChatGPT) as a *pair designer + pair developer* to:

- propose a UI strategy (pages around 179–181)
- write structured prompts that produce targeted UI guidance and code
- convert wireframes and flows into Flask templates + components
- add responsive HTML/CSS elements without being a frontend expert

This week is very *workflow heavy*: it is less "what is a transformer?" and more "how do we get from backend routes to a usable application screen?"

## Key terms (bolded the first time)
We will use these week-specific ideas repeatedly:

- **Wireframe** — a sketch (boxes + labels) of what the UI should contain and roughly how it should be laid out.
- **Flask templates** — HTML files rendered by Flask (often using Jinja2), letting you combine content + layout + Python variables.
- **Jinja2** — the templating language Flask uses to inject variables/loops/conditionals into HTML.
- **Responsive design** — designing pages so they work on different screen sizes (mobile, tablet, desktop).
- **Prompt scaffolding** — structuring a prompt into sections (objective, constraints, inputs, outputs) so the AI returns usable results.

## Figures extracted from the PDF
These are images embedded in the PDF pages for Week 07. Not all are equally useful (some are icons/background elements), but they are extracted and downloadable.

![](images/week_07/fig_01.png){fig-alt="Week 07 extracted figure 1"}

![](images/week_07/fig_02.png){fig-alt="Week 07 extracted figure 2"}

![](images/week_07/fig_03.png){fig-alt="Week 07 extracted figure 3"}

![](images/week_07/fig_04.png){fig-alt="Week 07 extracted figure 4"}

![](images/week_07/fig_05.png){fig-alt="Week 07 extracted figure 5"}

![](images/week_07/fig_06.png){fig-alt="Week 07 extracted figure 6"}

## 7.1 Getting our strategy from our AI tools
A key idea early in this week: do **strategy first**, then **code second**. The point is that you can waste a lot of time prompting for code before you have agreed what the UI is supposed to *do* and *feel like*.

### Why “strategy first” matters
- If you ask for “a frontend” without specifics, the AI returns generic boilerplate.
- Strategy prompts help you decide: pages, navigation, user flow, components, and naming.
- You get a UI that matches your backend data model instead of fighting it later.

### This week's prompt pattern (prompt scaffolding)
This week demonstrates writing a prompt with explicit blocks:

- **Role** (who the AI should act as)
- **Objective** (what the UI needs to achieve)
- **Context** (what already exists: backend routes, DB, etc.)
- **Constraints** (Flask templates, mobile-friendly, accessible)
- **Deliverables** (pages list, wireframe descriptions, template structure, CSS suggestions)

> "If we say  "generate a frontend for my application" without enough information, the guidance  will be too vague."

## Worked example: prompting for a UI plan (Quarto runnable code)
Below is a “prompt builder” approach: you store prompt sections as strings and assemble them. This makes prompts easier to iterate and reuse.

```{python}
#| label: ui-prompt-scaffold
#| eval: false
role = "Act as a professional Python developer specialising in Flask and UX."
objective = "Design a front end for a database-driven Flask quiz application."
context = "Backend exists with routes for login, quizzes, and results."
constraints = "Use Flask templates (Jinja2). Keep it responsive and accessible."
deliverables = "Return: (1) page list, (2) nav structure, (3) template folder structure, (4) CSS starter."

prompt = "

".join([role, objective, context, constraints, deliverables])
print(prompt)
```

## 7.2 From flows to pages: what screens does the user need?

This week frames UI work as a **user journey**: what does the user do first, next, and last?

A practical approach is to list screens as verbs: *Log in*, *Choose a quiz*, *Answer questions*, *See results*.

Once screens exist, you map navigation: where can the user go from each screen?

This is where AI is helpful: it can suggest missing pages (e.g., error states, empty-state screens).

## 7.3 Translating requirements into template structure

This week emphasises organising your project so templates don’t become a mess.

In Flask, a common pattern is a `templates/` folder and a `static/` folder.

Templates contain HTML/Jinja; static contains CSS, JavaScript, and images.

AI can draft a sensible baseline structure, but *you* must keep it consistent.

If your templates are inconsistent (different nav bars per page), your UI will feel broken.

## 7.4 Wireframes: how to ask the AI for layout help

A **wireframe** is not pretty — it is a constraint tool.

You describe boxes: header, sidebar, main content, footer.

This week shows using AI to turn a description into HTML skeleton.

When prompting: specify grid/layout system (Flexbox, CSS grid, Bootstrap) or you’ll get random HTML.

Be explicit about which elements repeat across pages (navbar, footer).

## 7.5 Responsive design basics (what this week wants you to learn)

This week's promise: you can achieve modern UI behaviour without deep frontend knowledge.

Responsive design usually means: a single codebase that adapts to screen width.

Practical knobs: `max-width`, `min-width`, breakpoints, and flexible grids.

AI is good at generating starter CSS, but you need to test in the browser.

Common failure: the UI looks fine on desktop but unusable on mobile.

## 7.6 Jinja2 integration: UI that actually connects to backend data

Static HTML is easy. The challenge is making pages dynamic.

This week expects you to connect templates to Flask route variables.

In Jinja2 you often loop over data: quizzes, questions, or results.

AI can generate the loop structure quickly, but you must match variable names to your actual Python.

Always confirm: what does the route pass into the template?

## 7.7 Building components: avoiding copy/paste templates

As your UI grows, duplication becomes the enemy.

In Flask/Jinja, you can create a base template and extend it.

This week's workflow benefits from: a base layout, then child pages.

AI can scaffold a `base.html` with blocks (`content`, `scripts`).

Pitfall: students forget to keep blocks consistent and pages break silently.

## 7.8 Testing UI logic (lightweight sanity checks)

Week 07 is not a testing week, but UI work still needs verification.

At minimum: confirm routes render, form submissions work, and nav links don’t 404.

AI can help generate checklists for manual testing.

If you have time, write a tiny smoke test using Flask’s test client.

## Code example: simple Jinja2 loop for quiz list
This matches this week's theme of converting backend data into pages.

```{html}
{% extends "base.html" %}
{% block content %}
<h1>Available quizzes</h1>
<ul>
  {% for quiz in quizzes %}
    <li><a href="/quiz/{{ quiz.id }}">{{ quiz.title }}</a></li>
  {% endfor %}
</ul>
{% endblock %}
```

## Code example: minimal responsive CSS skeleton
```{css}
body { max-width: 960px; margin: 0 auto; padding: 1rem; }
nav a { margin-right: 1rem; }
@media (max-width: 600px) {
  body { padding: 0.5rem; }
  nav a { display: block; margin: 0.25rem 0; }
}
```

## Summing up
- Week 07 uses ChatGPT to move from “backend works” to “users can actually use it”.
- The skill is not magic HTML generation: it’s **prompt scaffolding** + iteration.
- Wireframes + flows keep AI output grounded.
- Flask templates + Jinja2 are the bridge between Python data and the UI.
- Responsive design is essential: test on multiple screen sizes early.

## Quick checklist (week skills)
- [ ] I can write a “strategy prompt” before asking for UI code.
- [ ] I can list UI screens for a Flask app and map navigation between them.
- [ ] I can scaffold templates/static folders for a maintainable frontend.
- [ ] I can implement a base template + child templates with Jinja2 blocks.
- [ ] I can add basic responsive CSS and verify it in a browser.
